package ch.hearc.p2.game.physics;

import java.util.ArrayList;

import ch.hearc.p2.game.level.Level;
import ch.hearc.p2.game.level.LevelObject;
import ch.hearc.p2.game.level.tile.Tile;

public class Physics {

	private final float gravity = 0.0015f;

	public void handlePhysics(Level level, int delta) {

	}

	private boolean checkCollision(LevelObject obj, Tile[][] mapTiles) {
		// get only the tiles that matter
		ArrayList<Tile> tiles = obj.getBoundingShape().getTilesOccupying(mapTiles);
		for (Tile t : tiles) {
			// if this tile has a bounding shape
			if (t.getBoundingShape() != null) {
				if (t.getBoundingShape().checkCollision(obj.getBoundingShape())) {
					return true;
				}
			}
		}
		return false;
	}

	private boolean isOnGroud(LevelObject obj, Tile[][] mapTiles) {
		// we get the tiles that are directly "underneath" the characters, also
		// known as the ground tiles
		ArrayList<Tile> tiles = obj.getBoundingShape().getGroundTiles(mapTiles);

		// we lower the the bounding object a bit so we can check if we are
		// actually a bit above the ground
		obj.getBoundingShape().movePosition(0, 1);

		for (Tile t : tiles) {
			// not every tile has a bounding shape (air tiles for example)
			if (t.getBoundingShape() != null) {
				// if the ground and the lowered object collide, then we are on
				// the ground
				if (t.getBoundingShape().checkCollision(obj.getBoundingShape())) {
					// don't forget to move the object back up even if we are on
					// the ground!
					obj.getBoundingShape().movePosition(0, -1);
					return true;
				}
			}
		}

		// and obviously we have to move the object back up if we don't hit the
		// ground
		obj.getBoundingShape().movePosition(0, -1);

		return false;
	}

	private void handleCharacters(Level level, int delta) {
		for (Character c : level.getCharacters()) {

			// and now decelerate the character if he is not moving anymore
			if (!c.isMoving()) {
				c.decelerate(delta);
			}

			handleGameObject(c, level, delta);
		}
	}

}